
영속성 컨텍스트(Persistence Context)는 JPA에서 **엔티티(Entity) 객체를 관리**하는 일종의 **저장소**입니다. 이는 JPA의 핵심 개념으로, 애플리케이션과 데이터베이스 사이에서 **객체의 상태를 관리**하고, 데이터베이스와 동기화하는 역할을 합니다.

- **정의**:
    - 영속성 컨텍스트는 엔티티 객체를 저장하고, 객체의 상태 변화를 추적하며, 데이터베이스와 동기화하는 **엔티티 관리 환경**입니다.
    - JPA에서 `EntityManager`를 통해 영속성 컨텍스트에 접근하고 이를 제어할 수 있습니다.

## 요약

- **영속성 컨텍스트**는 JPA에서 엔티티를 관리하는 저장소로, 1차 캐시, 변경 감지, 쓰기 지연 등의 기능을 제공합니다.
- 이를 통해 **데이터베이스 접근 최소화**와 **데이터 일관성 유지**가 가능하지만, **메모리 관리**와 **트랜잭션 범위**에 유의해야 합니다.

## **1. 영속성 컨텍스트의 주요 특징**

### **1.1 엔티티를 관리**

- 영속성 컨텍스트는 데이터베이스에서 가져오거나 새로 생성된 엔티티 객체를 관리합니다.
- 관리 중인 엔티티를 **"영속 상태"**라고 합니다.
- 예를 들어, `find()` 메서드로 조회된 엔티티는 영속성 컨텍스트에서 관리됩니다.

---

### **1.2 1차 캐시**

- 영속성 컨텍스트는 1차 캐시 역할을 합니다.
- 동일한 트랜잭션 내에서 같은 엔티티를 다시 조회하면 데이터베이스에 접근하지 않고 1차 캐시에서 반환합니다.

---

### **1.3 변경 감지(Dirty Checking)**

- 영속성 컨텍스트는 관리 중인 엔티티의 상태를 지속적으로 감지합니다.
- 엔티티가 변경되면 트랜잭션이 커밋될 때 자동으로 데이터베이스에 업데이트 쿼리를 실행합니다.

---

### **1.4 쓰기 지연**

- 영속성 컨텍스트는 SQL 쿼리를 즉시 실행하지 않고 **쓰기 지연** 메커니즘을 사용합니다.
- `flush()` 또는 트랜잭션이 커밋될 때, 쌓아둔 쿼리가 데이터베이스에 반영됩니다.

---

### **1.5 엔티티 동일성 보장**

- 영속성 컨텍스트는 동일한 트랜잭션 내에서 동일한 엔티티 객체를 반환합니다.
- 즉, 같은 `@Id`를 가진 엔티티는 같은 인스턴스를 참조합니다.

---

## **2. 엔티티의 상태**

JPA에서 엔티티는 **4가지 상태**를 가질 수 있습니다:

### **2.1 비영속(Transient)**

- 영속성 컨텍스트에서 관리되지 않는 상태.
- 데이터베이스와 전혀 연관되지 않은 단순 객체.
```java
Customer customer = new Customer();
customer.setName("Alice");
```

### **2.2 영속(Managed)**

- 영속성 컨텍스트에서 관리되는 상태.
- 데이터베이스와 연동되며, 상태 변화가 감지됩니다.
```java
Customer customer = entityManager.find(Customer.class, 1L);
```

### **2.3 준영속(Detached)**

- 영속성 컨텍스트에서 더 이상 관리되지 않는 상태.
- 데이터베이스와 연동되지 않으므로 상태 변화가 감지되지 않습니다.
```java
entityManager.detach(customer);
```

### **2.4 삭제(Removed)**

- 영속성 컨텍스트에서 관리되지만, 삭제가 예약된 상태.
- 트랜잭션 커밋 시 데이터베이스에서 삭제됩니다.
```java
entityManager.remove(customer);
```

## **3. 영속성 컨텍스트의 동작 과정**

### **3.1 기본 흐름**

```java
EntityManager em = entityManagerFactory.createEntityManager(); 

em.getTransaction().begin();  

// 1. 비영속 상태에서 영속 상태로 변경 Customer 
customer = new Customer(); 
customer.setName("Alice"); 
em.persist(customer); // 영속 상태로 전환  

// 2. 1차 캐시에 저장됨 (데이터베이스에는 반영되지 않음) 
Customer cachedCustomer = em.find(Customer.class, customer.getId()); // 캐시에서 조회  

// 3. 변경 감지 (Dirty Checking) 
customer.setName("Bob"); // 상태 변화 추적  

// 4. 쓰기 지연 (SQL 쿼리 생성) 
em.getTransaction().commit(); // 데이터베이스에 변경사항 반영 

em.close();
```


### **3.2 엔티티 상태 변화**

#### **비영속 → 영속**

- `persist()`, `find()`, `merge()`를 호출하면 객체가 영속 상태로 전환됩니다.
```java
em.persist(customer); // 비영속 -> 영속
```

#### **영속 → 준영속**

- `detach()`를 호출하거나 `EntityManager`가 종료되면 준영속 상태로 전환됩니다.
```java
em.detach(customer); // 영속 -> 준영속
```

#### **영속 → 삭제**

- `remove()`를 호출하면 삭제 상태로 전환됩니다.
```java
em.remove(customer); // 영속 -> 삭제
```


## **4. 영속성 컨텍스트의 장점**

### **4.1 데이터베이스 접근 최소화**

- 1차 캐시로 인해 동일한 트랜잭션 내에서는 데이터베이스 접근을 줄입니다.

### **4.2 변경 감지**

- 객체의 상태 변화를 자동으로 감지하여 SQL 쿼리를 생성합니다.

### **4.3 데이터 일관성 보장**

- 동일한 트랜잭션 내에서는 동일한 엔티티를 반환하여 데이터 일관성을 유지합니다.

---

## **5. 영속성 컨텍스트의 단점**

### **5.1 메모리 사용량 증가**

- 1차 캐시에 데이터가 저장되므로, 대량의 데이터를 처리할 경우 메모리 사용량이 증가할 수 있습니다.

### **5.2 트랜잭션 의존성**

- 영속성 컨텍스트는 트랜잭션이 종료되면 소멸하므로, 장기적인 객체 관리에는 부적합합니다.

### **5.3 복잡성**

- `merge`, `detach` 등 다양한 상태 전환 메서드와 개념을 이해해야 하므로 학습 곡선이 있습니다.

---

## **6. 영속성 컨텍스트에서 자주 겪는 문제**

### **6.1 LazyInitializationException**

- **문제**:
    - `Lazy` 로딩 엔티티를 트랜잭션 밖에서 접근하려고 하면 발생.
- **해결 방법**:
    - 트랜잭션 범위를 확장하거나, 필요한 데이터를 미리 로드(Eager Fetch)하거나 DTO를 사용.

---

### **6.2 N+1 문제**

- **문제**:
    - 연관 엔티티를 조회할 때 추가적인 쿼리가 예상보다 더 많이 발생.
- **해결 방법**:
    - `fetch join`, `@EntityGraph`를 사용해 최적화.

---

### **6.3 변경 감지 실패**

- **문제**:
    - 영속성 컨텍스트에 포함되지 않은 객체는 변경 사항이 반영되지 않음.
- **해결 방법**:
    - 엔티티를 영속성 컨텍스트에 포함시키거나 `merge()` 호출.