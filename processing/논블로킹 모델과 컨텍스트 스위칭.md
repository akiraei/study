**단일 쓰레드 기반 논블로킹 모델**에서는 **전통적인 의미의 컨텍스트 스위칭(다른 쓰레드 간의 전환)**은 발생하지 않습니다. 하지만, **단일 쓰레드 내에서도 작업 간 전환이 이루어질 수 있는데**, 이를 **"작업 컨텍스트 전환"**이라고 볼 수 있습니다.

---

## **1. 단일 쓰레드 모델에서의 작업 전환**

### **1.1 논블로킹 I/O의 작동 원리**

- 단일 쓰레드 모델(Node.js, Spring WebFlux의 Netty 등)에서는 **I/O 작업을 비동기로 처리**합니다.
- 비동기 작업은 OS 레벨에서 처리되며, 완료되면 **이벤트 루프**에 다시 결과를 전달합니다.
- 따라서, **다른 쓰레드 간 전환이 필요 없고**, CPU는 한 번에 하나의 작업을 처리합니다.

---

### **1.2 이벤트 루프와 작업 전환**

단일 쓰레드 내에서도 이벤트 루프가 다음 작업으로 넘어가기 위해 현재 작업을 멈추고 대기 중인 다른 작업으로 전환해야 할 수 있습니다.

#### **예: 작업 전환 과정**

1. 이벤트 루프가 실행 중인 작업을 종료.
2. 큐에 쌓인 다음 작업으로 전환.
3. 작업 간 상태를 유지해야 하는 경우, 이를 적절히 관리.

이 과정에서 발생하는 작업 전환은 전통적인 **OS 쓰레드 간 컨텍스트 스위칭**보다 훨씬 가벼운 작업입니다.

---

### **1.3 단일 쓰레드에서의 전환과 컨텍스트 스위칭 차이**

- 단일 쓰레드 모델에서는 전통적인 의미의 **컨텍스트 스위칭**이 아니라, 이벤트 루프 내에서 작업 전환만 발생.
- 이러한 작업 전환은 일반적인 쓰레드 간 컨텍스트 스위칭처럼 **레지스터 저장/복원**, **캐시 무효화** 같은 오버헤드가 없으므로 비용이 훨씬 낮습니다.

---

## **2. 논블로킹 환경에서 컨텍스트 스위칭은 왜 줄어드는가?**

### **2.1 멀티쓰레드 모델의 비용**

멀티쓰레드 환경에서는 다음과 같은 작업이 발생:

1. 쓰레드 간 전환을 위한 **레지스터 저장/복원**.
2. CPU 캐시 무효화와 재로딩.
3. OS 스케줄러에 의한 추가적인 관리 비용.

### **2.2 논블로킹 모델의 비용**

논블로킹 모델에서는 다음과 같은 이유로 비용이 줄어듭니다:

1. 단일 쓰레드만 사용하므로 **레지스터 저장/복원** 작업이 필요 없음.
2. 작업 간 전환은 이벤트 루프 내에서 가볍게 처리.
3. OS 레벨에서 쓰레드 스케줄링 대신 **비동기 콜백**으로 전환.

---

## **3. 단일 쓰레드에서 컨텍스트 스위칭이 "거의 필요 없는" 이유**

단일 쓰레드 모델은 **이벤트 루프와 작업 큐**를 기반으로 동작하므로, 전통적인 멀티쓰레드 방식의 컨텍스트 스위칭이 아예 발생하지 않습니다. 대신 다음과 같은 방식으로 동작합니다:

### **3.1 이벤트 루프의 작업 처리**

1. 이벤트 루프는 작업 큐에서 대기 중인 작업을 순차적으로 처리.
2. CPU가 놀지 않고 작업을 효율적으로 처리.

### **3.2 OS 레벨의 논블로킹 지원**

- 논블로킹 I/O는 OS 레벨에서 지원하므로, CPU는 I/O 대기 시간 동안 다른 작업을 처리 가능.
- OS 자체에서 논블로킹 시스템 콜(API)을 제공.

#### **예: Node.js 비동기 I/O**

javascript

코드 복사

`const fs = require('fs');  console.log("Start");  fs.readFile('file.txt', (err, data) => {     if (err) throw err;     console.log("File read completed"); });  console.log("End");`

출력:

arduino

코드 복사

`Start End File read completed`

- `fs.readFile`은 비동기 논블로킹 방식으로 처리.
- 이벤트 루프는 파일 읽기가 끝나기 전 다른 작업(`End 출력`)을 처리.

---

## **4. 결론**

### **컨텍스트 스위칭**

- **멀티쓰레드 모델**:
    - 전통적인 **컨텍스트 스위칭** 발생.
    - 쓰레드 간 전환 비용(레지스터 저장/복원, 캐시 무효화 등)이 큼.
- **단일 쓰레드 논블로킹 모델**:
    - 쓰레드 간 컨텍스트 스위칭은 없음.
    - 작업 전환만 발생하며, 비용이 훨씬 적음.

### **논블로킹 I/O 모델의 이점**

- 단일 쓰레드 기반으로 쓰레드 간 전환 비용을 제거.
- I/O 작업을 OS에 위임하고, 이벤트 루프가 효율적으로 작업을 처리.
- CPU 바운드 작업이 아닌 **I/O 바운드 작업**에서는 최적의 성능 제공.

논블로킹 I/O 환경에서는 전통적인 의미의 쓰레드 컨텍스트 스위칭이 없으므로, 이러한 작업 방식이 멀티쓰레드 환경보다 효율적입니다