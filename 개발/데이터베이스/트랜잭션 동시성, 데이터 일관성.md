
수평 확장에서의 최적화는 **문제의 성격**, **데이터 액세스 패턴**, **비즈니스 요구사항**에 따라 달라질 수 있습니다. 이를 고려한 설계가 필요합니다.
## **요약**

### **문제 핵심**

- **트랜잭션 동시성**: 여러 인스턴스가 동일한 데이터를 동시에 수정하려고 할 때 발생하는 충돌 문제.
- **데이터 일관성**: 여러 인스턴스 간 데이터가 불일치하게 되는 문제.

### **해결 전략**

1. **동시성 제어**:
    - 비관적 락, 낙관적 락, 분산 트랜잭션 등을 사용.
2. **데이터 일관성 보장**:
    - 캐시 동기화, 읽기-쓰기 분리, 트랜잭션 격리 수준 설정.
3. **트레이드오프**:
    - 성능(높은 동시성)과 데이터 안전성(높은 일관성) 간의 균형을 비즈니스 요구사항에 맞게 조정.


## **1. 트랜잭션 동시성**

### **문제 정의**

- 여러 애플리케이션 인스턴스가 동시에 동일한 데이터를 수정하려고 할 때, **경쟁 상태(Race Condition)**가 발생.
- 예를 들어, 두 사용자가 동시에 동일한 재고 데이터를 수정하려고 하면, 하나의 수정 작업이 다른 작업을 덮어쓰는 문제가 발생.

### **해결 방안**

1. **비관적 락(Pessimistic Locking)**:
    - 데이터에 락을 걸어 다른 트랜잭션이 접근하지 못하게 함.
    - **적합한 상황**: 데이터 충돌 가능성이 높을 때.
    
1. **낙관적 락(Optimistic Locking)**:
    - 데이터 수정 시 변경 여부를 검증하여 충돌을 감지.
    - **적합한 상황**: 데이터 충돌 가능성이 낮고 성능이 중요한 경우.
    
1. **분산 트랜잭션**:
    - 여러 데이터베이스와 애플리케이션 간 트랜잭션 일관성을 유지.
    - **적합한 상황**: 여러 데이터소스와 복잡한 트랜잭션이 필요한 경우.

## **2. 데이터 일관성**

### **문제 정의**

- 여러 애플리케이션 인스턴스가 동일한 데이터베이스를 공유하거나, **캐시**를 사용하는 경우 데이터 불일치 문제가 발생.
- 예를 들어, 한 인스턴스에서 데이터가 수정되었지만, 다른 인스턴스의 캐시는 여전히 이전 데이터를 보관하고 있을 수 있음.

### **해결 방안**

1. **캐시 동기화**:
    - 분산 캐시(Hazelcast, Redis)와 메시지 브로커(Kafka, RabbitMQ) 등을 활용하여 캐시 데이터를 동기화.
    - **적합한 상황**: 캐시를 사용하는 애플리케이션.
    
1. **읽기-쓰기 분리**:
    - 읽기 전용 데이터베이스(Read Replica)와 쓰기 전용 데이터베이스를 분리하여 충돌 가능성을 낮춤.
    - **적합한 상황**: 읽기 요청이 많은 시스템.
    
1. **정상성 조건 설정**:
    - 데이터베이스의 트랜잭션 격리 수준을 조정하여 데이터 일관성을 보장.
    - 격리 수준: READ COMMITTED, REPEATABLE READ, SERIALIZABLE.
    - **적합한 상황**: 데이터 일관성이 최우선인 시스템.

## **3. 트랜잭션 동시성과 데이터 일관성의 관계**

### **트레이드오프**

- **높은 동시성**:
    - 여러 작업이 동시에 실행될 수 있도록 설계하면 성능이 향상되지만, 데이터 일관성을 유지하기 어려워질 수 있음.
- **높은 일관성**:
    - 데이터를 항상 일관되게 유지하려면 락이나 동기화를 강화해야 하므로 성능이 저하될 수 있음.

### **균형 잡기**

- **비즈니스 요구사항**에 따라 트랜잭션 동시성과 데이터 일관성 간의 균형을 설정.
    - 예: 금융 시스템에서는 데이터 일관성이 중요하므로 동시성을 포기하고 강한 락 메커니즘을 사용.
    - 예: SNS 시스템에서는 성능이 중요하므로 약한 일관성을 허용하고 높은 동시성을 유지.