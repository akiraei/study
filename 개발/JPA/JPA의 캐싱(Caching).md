JPA는 **성능 최적화**를 위해 캐싱 메커니즘을 제공합니다. 캐싱은 데이터베이스 접근을 줄이고 애플리케이션의 속도를 높이는 데 중요한 역할을 합니다. JPA에서 주요 캐싱은 **1차 캐시**와 **2차 캐시**로 나뉩니다.

## **1. JPA의 1차 캐시**

### **1.1 정의**

1차 캐시는 **영속성 컨텍스트(Persistence Context)** 수준에서 작동하는 캐시입니다. 영속성 컨텍스트는 엔티티 매니저(EntityManager)가 관리하는 객체이고, 1차 캐시는 해당 컨텍스트 내에서 데이터베이스에 직접 접근하지 않고, 캐시에 저장된 엔티티를 조회하도록 도와줍니다.

### **1.2 특징**

- **트랜잭션 단위**로 작동:
    - 한 트랜잭션 내에서만 유효합니다.
    - 트랜잭션이 종료되면 캐시도 소멸합니다.
- **EntityManager**별로 독립:
    - 서로 다른 `EntityManager`는 서로 다른 1차 캐시를 가집니다.
- **엔티티 키 기준으로 작동**:
    - 1차 캐시는 엔티티의 **@Id** (Primary Key)를 기준으로 저장됩니다.


### **1.3 작동 원리**

1차 캐시는 다음과 같은 순서로 작동합니다:

1. **조회 시도**:
    - `EntityManager`가 데이터베이스에 접근하기 전에 1차 캐시에서 먼저 엔티티를 검색합니다.
2. **데이터베이스 접근 최소화**:
    - 동일한 트랜잭션에서 이미 조회된 엔티티는 캐시에서 반환되며, 추가적인 데이터베이스 쿼리가 실행되지 않습니다. 
1. **변경 감지**:
    - 엔티티가 변경되면 영속성 컨텍스트가 이를 추적하여 데이터베이스 업데이트 시 변경사항을 반영합니다.

#### **예제**

```java
EntityManager em = entityManagerFactory.createEntityManager(); em.getTransaction().begin(); 

// 첫 번째 조회: 데이터베이스 접근 
Customer customer1 = em.find(Customer.class, 1L); System.out.println(customer1); 

// 두 번째 조회: 1차 캐시에서 가져옴 
Customer customer2 = em.find(Customer.class, 1L); System.out.println(customer2); 

em.getTransaction().commit();
em.close();
```

- 첫 번째 `em.find()`는 데이터베이스에서 데이터를 가져오고 1차 캐시에 저장합니다.
- 두 번째 `em.find()`는 데이터베이스에 쿼리를 날리지 않고 1차 캐시에서 데이터를 반환합니다.

### **1.4 장점**

- 데이터베이스 접근 최소화로 성능 최적화.
- 같은 트랜잭션 내에서 데이터 일관성 유지.

### **1.5 단점**

- **트랜잭션 단위로만 작동**:
    - 트랜잭션이 종료되면 캐시가 소멸하기 때문에 캐싱 지속성이 없습니다.
- 대규모 데이터를 처리할 때 메모리 사용량 증가.

## **2. JPA의 2차 캐시**

### **2.1 정의**

2차 캐시는 **영속성 컨텍스트 외부(EntityManagerFactory)** 에서 작동하는 캐시로, 애플리케이션 전역에서 공유할 수 있는 캐시입니다. 이는 데이터베이스 조회를 줄이고, 여러 트랜잭션 간 데이터 재사용성을 높이기 위해 사용됩니다.
- 영속성 컨텍스트: EntityManager
- 영속성 컨텍스트 외부: EntityManagerFactory

### **2.2 특징**

- **엔티티매니저 팩토리 수준**에서 작동:
    - 여러 `EntityManager` 인스턴스 간에 공유됩니다.
- **영속성 컨텍스트 종료 후에도 데이터 유지**:
    - 애플리케이션 전역에서 캐시된 데이터를 재사용할 수 있습니다.
- **사용 여부는 선택적**:
    - JPA 자체는 2차 캐시를 제공하지 않지만, 구현체(Hibernate 등)가 이를 지원합니다.
- **L2 캐시(Layer 2 캐시: 2차 캐시)를 구현체에 위임**:
    - Hibernate에서는 `Ehcache`, `Infinispan`, `OSCache` 등과 연동하여 2차 캐시를 지원.

### **2.3 설정 방법 (Hibernate 기준)**

#### **2차 캐시 활성화**

Hibernate에서 2차 캐시를 사용하려면 다음과 같이 설정합니다:

##### **1. `hibernate.cfg.xml` 설정**

```xml
<property name="hibernate.cache.use_second_level_cache">true</property> <property name="hibernate.cache.region.factory_class">org.hibernate.cache.jcache.JCacheRegionFactory</property> 
<property name="hibernate.javax.cache.provider">org.ehcache.jsr107.EhcacheCachingProvider</property>
```

##### **2. 엔티티에 캐시 적용**

```java
import jakarta.persistence.Cacheable;

@Entity
@Cacheable 
public class Customer {     

@Id     
@GeneratedValue(strategy = GenerationType.IDENTITY)     
private Long id;      

private String name;      
// Getters and Setters 
}
```


### **2.4 작동 원리**

1. 첫 번째 요청 시 데이터베이스에서 데이터를 가져와 2차 캐시에 저장.
2. 동일한 데이터에 대한 후속 요청은 2차 캐시에서 데이터를 반환.
3. 데이터가 변경되면 2차 캐시가 무효화되거나 동기화됩니다.


### **2.5 장점**

- **다중 트랜잭션에서 데이터 재사용**:
    - 2차 캐시를 통해 여러 `EntityManager`에서 같은 데이터를 반복적으로 가져오지 않음.
- **데이터베이스 부하 감소**:
    - 자주 참조되는 데이터를 캐시로 제공하여 성능 향상.

### **2.6 단점**

- **데이터 일관성 문제**:
    - 캐시된 데이터가 실제 데이터베이스와 불일치할 가능성이 있음.
- **메모리 사용량 증가**:
    - 캐시로 인해 메모리 사용량이 늘어날 수 있음.
- **구성 복잡성**:
    - 2차 캐시 설정 및 사용은 구현체와 캐시 제공 라이브러리(Ehcache, Infinispan 등)에 따라 달라짐.



## **3. JPA 캐시 비교**

| **특징**       | **1차 캐시**                    | **2차 캐시**                   |
| ------------ | ---------------------------- | --------------------------- |
| **캐시 범위**    | `EntityManager`(영속성 컨텍스트) 수준 | `EntityManagerFactory` 수준   |
| **캐시 지속 시간** | 트랜잭션 동안 유지                   | 애플리케이션 전역에서 유지 가능           |
| **공유 여부**    | `EntityManager` 간에 공유되지 않음   | 모든 `EntityManager` 간에 공유 가능 |
| **설정 필요 여부** | 자동 활성화                       | 구현체(Hibernate)에서 추가 설정 필요   |
| **주요 목적**    | 트랜잭션 내 성능 최적화                | 여러 트랜잭션 간 데이터 재사용성 제공       |


## **4. 자주 겪는 문제**

### **4.1 데이터 일관성 문제**

2차 캐시는 데이터베이스 변경을 즉각 반영하지 못해 데이터가 불일치할 수 있습니다. 이를 해결하려면:

- 데이터 변경 시 캐시 무효화 정책 사용.
- 캐시 TTL(유효 기간)을 설정.

### **4.2 메모리 사용량 문제**

- 대량의 데이터를 캐시에 저장하면 메모리가 부족해질 수 있습니다.
- 필요한 데이터만 캐싱하도록 **캐시 범위를 제한**.

### **4.3 예상치 못한 캐싱**

- 1차 캐시는 자동으로 작동하므로, 동일 트랜잭션 내에서 데이터를 수동으로 갱신하지 않으면 캐싱된 데이터가 반환될 수 있습니다.

### **5. 요약**

- **1차 캐시**:
    - 트랜잭션 단위로 작동하며, 기본적으로 활성화.
    - 동일 트랜잭션 내에서는 데이터베이스 접근을 줄여 성능 최적화.
- **2차 캐시**:
    - 애플리케이션 전역에서 데이터 재사용성을 제공.
    - Hibernate 등의 구현체와 캐시 제공 라이브러리를 통해 설정 가능.
- **사용 팁**:
    - 자주 사용되는 정적 데이터는 2차 캐시에 저장.
    - 대량의 데이터는 캐시하지 않도록 주의.