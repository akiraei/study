**영속성 컨텍스트의 상태 변화는 ORM(Object-Relational Mapping)의 목적**과 매우 밀접하게 관련이 있습니다. JPA와 같은 ORM 기술은 객체 지향 프로그래밍 언어(Java 등)와 관계형 데이터베이스(SQL 기반 시스템) 간의 **불일치를 해소**하고, 개발자가 객체 중심으로 작업할 수 있도록 설계되었습니다. 이 과정에서 **엔티티의 상태 변화**는 ORM의 주요 목적을 달성하기 위한 핵심적인 메커니즘입니다.

## **ORM의 목적과 영속성 컨텍스트 상태 변화의 관계**

### **1. 데이터베이스와 객체 간의 불일치 해소**

#### **ORM의 목적**

- 객체 지향 언어는 메모리에서 관리되는 객체를 기반으로 작업하지만, 관계형 데이터베이스는 테이블 기반으로 데이터를 관리합니다.
- ORM은 **데이터베이스의 데이터(테이블, 행)를 객체로 매핑**하여 개발자가 객체 중심으로 작업할 수 있도록 돕습니다.

#### **상태 변화와의 관계**

- 객체의 상태 변화를 영속성 컨텍스트가 관리하며, 데이터베이스와의 동기화를 자동화합니다.
    - 예: `Customer` 객체의 필드 값을 변경하면, **Dirty Checking**을 통해 변경 사항이 데이터베이스에 반영됩니다.
- 상태 변화(영속 → 준영속 등)는 객체와 데이터베이스 간의 일관성을 유지하기 위해 필요합니다.


### **2. 데이터 변경 추적 (Change Tracking)**

#### **ORM의 목적**

- 객체의 변경 사항을 추적하고, 이를 데이터베이스에 자동으로 반영(INSERT, UPDATE, DELETE)하여 개발자의 수동 작업을 줄이는 것.

#### **상태 변화와의 관계**

- 영속 상태의 엔티티는 **영속성 컨텍스트**에 의해 관리되며, 데이터 변경 사항은 자동으로 감지(Dirty Checking)되어 데이터베이스에 반영됩니다.
- 이를 통해 객체의 상태를 명시적으로 변경하지 않아도 데이터베이스와 동기화됩니다.

### **3. 생산성과 유지보수성 향상**

#### **ORM의 목적**

- SQL 쿼리 작성과 같은 반복 작업을 최소화하고, 객체 지향적인 방식으로 데이터베이스 작업을 처리하여 코드의 생산성과 유지보수성을 높임.

#### **상태 변화와의 관계**

- JPA는 엔티티 상태 변화에 따라 적절한 SQL 쿼리(INSERT, UPDATE, DELETE)를 생성하고 실행합니다.
- 개발자는 데이터베이스 작업에 집중하지 않고, 객체 지향적으로 비즈니스 로직을 구현할 수 있습니다.
    - 예: `entityManager.remove(customer)`를 호출하면, DELETE 쿼리가 자동으로 실행됩니다.

### **4. 데이터 일관성과 트랜잭션 관리**

#### **ORM의 목적**

- 객체 상태와 데이터베이스 간의 일관성을 유지하고, 트랜잭션을 통해 데이터의 무결성을 보장.

#### **상태 변화와의 관계**

- 트랜잭션 커밋 시, 영속 상태의 모든 엔티티 변경 사항이 데이터베이스에 반영됩니다.
- 상태 변화(영속 → 준영속 → 삭제 등)를 통해 트랜잭션 내에서 데이터의 유효성과 무결성을 관리합니다.

### **5. 지연 로딩과 효율성**

#### **ORM의 목적**

- 필요할 때만 데이터를 로드하여 성능을 최적화하고, 메모리 사용량을 줄임.

#### **상태 변화와의 관계**

- 지연 로딩은 영속 상태의 엔티티에서만 작동합니다. 엔티티가 준영속 상태로 전환되면, 지연 로딩을 사용할 수 없습니다.
- 따라서, 상태 변화는 성능 최적화를 위한 데이터 로딩 전략에도 영향을 미칩니다.

## **영속성 컨텍스트 상태 변화의 목적**

영속성 컨텍스트 상태 변화는 ORM의 근본적인 목적을 달성하기 위해 설계된 메커니즘입니다. 각 상태는 특정 목적을 달성하기 위해 사용됩니다.

| **상태**  | **ORM의 목적**                                         |
| ------- | --------------------------------------------------- |
| **비영속** | 객체와 데이터베이스 간의 독립성을 유지하여 초기 객체 생성이나 비즈니스 로직 테스트를 지원. |
| **영속**  | 객체와 데이터베이스 간의 일관성 유지 및 자동 변경 추적.                    |
| **준영속** | 메모리 사용량 절감 및 데이터베이스 연결 해제 후 독립적으로 객체를 유지.           |
| **삭제**  | 데이터베이스에서 객체를 삭제하여 객체 지향 모델과 관계형 데이터 모델의 일관성 유지.     |

---

## **결론**

영속성 컨텍스트에서의 엔티티 상태 변화는 ORM이 제공하는 **추상화, 데이터 변경 추적, 성능 최적화** 등의 기능을 가능하게 하기 위한 핵심 메커니즘입니다. 이를 통해 개발자는 데이터베이스와 객체 간의 복잡한 작업을 추상화하여 생산성을 높이고, 데이터의 일관성과 무결성을 유지할 수 있습니다.